{% extends 'base.html' %}

{% block content %}
<div class="editor-container">
    <div class="sidebar">
        <div class="sidebar-header">Segments</div>
        <div class="segment-list" id="segment-list">
            {% for para in structure %}
                {% for seg in para.segments %}
                    <div class="segment-item {% if seg.target_text %}translated{% endif %}" 
                         id="seg-item-{{ seg.id }}"
                         onclick="loadSegment({{ seg.id }})">
                        <b>{{ para.p_idx + 1 }}.{{ seg.s_idx + 1 }}</b>: {{ seg.source_text[:50] }}...
                    </div>
                {% endfor %}
            {% endfor %}
        </div>
    </div>
    
    <div class="main-editor">
        <div class="editor-toolbar">
            <button class="btn btn-outline-secondary btn-icon btn-sm" onclick="prevSegment()" title="Previous (Ctrl+B)">
                <i data-lucide="arrow-left"></i>
            </button>
            <button class="btn btn-primary btn-icon btn-sm" onclick="nextSegment()" title="Next (Ctrl+N)">
                <i data-lucide="arrow-right"></i>
            </button>
            <div class="vr mx-2"></div>
            <button class="btn btn-outline-dark btn-icon btn-sm" onclick="copySource()" title="Copy Source (Ctrl+I)">
                <i data-lucide="copy"></i>
            </button>
            <button class="btn btn-outline-warning btn-icon btn-sm" onclick="useTM()" title="Use TM (Ctrl+T)">
                <i data-lucide="sparkles"></i>
            </button>
            <button class="btn btn-outline-success btn-icon btn-sm" onclick="requestMT()" title="Translate MT">
                <i data-lucide="bot"></i>
            </button>
            <button class="btn btn-outline-danger btn-icon btn-sm" onclick="mergePrev()" title="Merge with Previous (Ctrl+J)">
                <i data-lucide="merge"></i>
            </button>
             <div class="vr mx-2"></div>
            <button class="btn btn-outline-primary btn-icon btn-sm" data-bs-toggle="modal" data-bs-target="#searchModal" title="Search (Ctrl+Shift+F)">
                <i data-lucide="search"></i>
            </button>
             <button class="btn btn-outline-dark btn-icon btn-sm" onclick="toggleContext()" title="Toggle Context">
                <i data-lucide="eye"></i>
            </button>
             <button class="btn btn-outline-secondary btn-icon btn-sm" onclick="toggleNotes()" title="Toggle Notes">
                <i data-lucide="sticky-note"></i>
            </button>
             <a href="{{ url_for('main.export_project', project_id=project.id) }}" class="btn btn-outline-secondary btn-icon btn-sm" title="Export DOCX">
                <i data-lucide="download"></i>
            </a>
            
            <div class="progress-container">
                <span id="progress-text">0/0</span>
                <div class="progress">
                    <div id="progress-bar" class="progress-bar bg-success" role="progressbar" style="width: 0%"></div>
                </div>
                <span class="badge bg-light text-dark border" id="status-indicator">Saved</span>
            </div>
        </div>
        
        <div class="work-area">
             <div id="context-panel" class="context-panel">
                <strong>Context:</strong> <span id="context-text"></span>
                <button class="btn btn-sm btn-link p-0 ms-2" onclick="mergeParagraph()" title="Merge full paragraph">
                    (Edit Full Paragraph)
                </button>
             </div>
             
             <div>
                <label class="info-label">Source</label>
                <div id="source-display" class="source-card">Select a segment...</div>
             </div>
             
             <div style="flex: 1; display: flex; flex-direction: column;">
                <label class="info-label">Target</label>
                <textarea id="target-input" class="form-control target-editor" placeholder="Type translation here..."></textarea>
             </div>
             
             <div id="notes-container" class="notes-container">
                <label class="info-label">Notes</label>
                <textarea id="note-input" class="form-control note-editor" placeholder="Add notes..."></textarea>
             </div>
        </div>

    </div>
    
    <div class="right-sidebar">
        <!-- TOP: Bible -->
        <div class="right-sidebar-top">
            <label class="info-label"><i data-lucide="book-open" style="width:14px;"></i> Bible</label>
            
            <div class="mb-2">
                <select id="bible-version-select" class="form-select form-select-sm mb-1" onchange="onVersionChange()">
                    <option value="">Loading versions...</option>
                </select>
                <select id="bible-book-select" class="form-select form-select-sm mb-1">
                    <option value="">Select Book...</option>
                </select>
                <div class="input-group input-group-sm mb-1">
                    <span class="input-group-text">Ch</span>
                    <input type="number" id="bible-chapter-input" class="form-control" placeholder="1">
                    <span class="input-group-text">Vs</span>
                    <input type="text" id="bible-verse-input" class="form-control" placeholder="1 or 1-5">
                    <button class="btn btn-outline-primary" onclick="fetchCustomBibleText()">OK</button>
                </div>
            </div>

            <div id="bible-content-area" class="flex-grow-1 border rounded p-2 bg-light overflow-auto" style="font-size: 0.9em;">
                <p class="text-muted text-center mt-3">Select details and click OK, or click a highlighted reference in the source text.</p>
            </div>
            <button class="btn btn-sm btn-outline-primary w-100 mt-2" onclick="pasteBibleText()">
                <i data-lucide="copy"></i> Paste to Target
            </button>
        </div>
        
        <!-- BOTTOM: Info -->
        <div class="right-sidebar-bottom">
            <div class="mb-2 pb-1 border-bottom">
                <label class="info-label"><i data-lucide="layers" style="width:14px;"></i> Resources</label>
            </div>
            
            <div class="info-section" id="section-tm" style="display:none;">
                 <label class="info-label">Translation Memory</label>
                 <div id="tm-info" class="info-card"><span id="tm-match-text"></span></div>
            </div>
            <div class="info-section" id="section-glossary" style="display:none;">
                 <label class="info-label">Glossary</label>
                 <div id="glossary-info" class="info-card"><span id="glossary-text"></span></div>
            </div>
             <div class="info-section" id="section-resources" style="display:none;">
                 <label class="info-label">Resources</label>
                 <div id="links-info" class="d-flex flex-column gap-2">
                     <!-- Links injected here -->
                 </div>
            </div>
        </div>
    </div>
</div>

<script>
    let currentSegmentId = null;
    let currentTmMatch = null;
    let segments = []; 
    let totalSegments = 0;
    
    // Initialize segments list
    {% for para in structure %}
        {% for seg in para.segments %}
            segments.push({{ seg.id }});
        {% endfor %}
    {% endfor %}
    totalSegments = segments.length;

    // --- Progress Logic ---
    function updateProgress() {
        const translatedCount = document.querySelectorAll('.segment-item.translated').length;
        const percent = totalSegments > 0 ? Math.round((translatedCount / totalSegments) * 100) : 0;
        
        document.getElementById('progress-text').innerText = `${translatedCount}/${totalSegments}`;
        document.getElementById('progress-bar').style.width = `${percent}%`;
        document.getElementById('progress-bar').innerText = `${percent}%`;
    }

    // --- Context Logic ---
    function toggleContext() {
        const panel = document.getElementById('context-panel');
        panel.classList.toggle('show');
    }
    
    function mergeParagraph() {
        if (!currentSegmentId) return;
        
        // We need paragraph ID. It's not stored in global var, but we have it in data response or structure.
        // Let's refactor loadSegment to store currentParaId.
        if(!confirm("This will merge all segments in this paragraph into one. Continue?")) return;
        
        // We need to know the paragraph ID. 
        // Simplest way: The API /api/segment/ID returns paragraph_context but not ID (Wait, I added paragraph_id in previous step).
        // Let's fetch it from current state or reload it.
        // For now, let's assume we have it. I need to update loadSegment to save it.
        if (window.currentParaId) {
             fetch(`/api/paragraph/${window.currentParaId}/merge`, {method: 'POST'})
                .then(r => r.json())
                .then(data => {
                    if(data.status === 'success') {
                        // Reload and jump to new segment
                        window.location.href = window.location.pathname + "?segment=" + data.new_segment_id;
                    } else {
                        alert("No changes or error.");
                    }
                });
        }
    }
    
    // --- Notes Logic ---
    function toggleNotes() {
        const container = document.getElementById('notes-container');
        container.classList.toggle('show');
    }

    function loadSegment(id) {
        if (currentSegmentId && currentSegmentId !== id) {
            saveSegment(currentSegmentId);
        }
        
        currentSegmentId = id;
        
        document.querySelectorAll('.segment-item').forEach(el => el.classList.remove('active'));
        const item = document.getElementById(`seg-item-${id}`);
        if(item) {
            item.classList.add('active');
            item.scrollIntoView({behavior: "smooth", block: "center"});
        }
        
        fetch(`/api/segment/${id}`)
            .then(r => r.json())
            .then(data => {
                window.currentParaId = data.paragraph_id; // Store for merge logic
                
                // Source Text (Highlight Links)
                const sourceDisplay = document.getElementById('source-display');
                // Escape HTML first to prevent XSS if we are setting innerHTML
                const safeText = data.source_text.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
                
                sourceDisplay.innerHTML = highlightRefs(safeText, data.bible_data, data.egw_data);

                document.getElementById('context-text').innerText = data.paragraph_context;
                document.getElementById('target-input').value = data.target_text || "";
                document.getElementById('note-input').value = data.note || "";
                
                // --- Info Panel Dynamic Visibility ---
                
                // TM Info
                currentTmMatch = data.tm_match;
                const tmSection = document.getElementById('section-tm');
                const tmSpan = document.getElementById('tm-match-text');
                
                if (data.tm_match) {
                    tmSpan.innerText = `${data.tm_score}% - ${data.tm_match}`;
                    tmSpan.className = data.tm_score === 100 ? "text-success" : "text-warning";
                    tmSection.style.display = 'block';
                } else {
                    tmSection.style.display = 'none';
                }
                
                // Glossary
                const glosSection = document.getElementById('section-glossary');
                const glosSpan = document.getElementById('glossary-text');
                
                if (data.glossary_matches && data.glossary_matches.length > 0) {
                    glosSpan.innerText = data.glossary_matches.map(m => `${m[0]}->${m[1]}`).join(', ');
                    glosSpan.className = "text-danger";
                    glosSection.style.display = 'block';
                } else {
                    glosSection.style.display = 'none';
                }
                
                // Links
                const linksSection = document.getElementById('section-resources');
                const linksSpan = document.getElementById('links-text');
                linksSpan.innerHTML = "";
                let hasLinks = false;
                
                if (data.bible_data) {
                    linksSpan.innerHTML += `<a href="${data.bible_data.en}" target="_blank" class="me-2 btn btn-sm btn-outline-primary">See on BibleGateway</a>`;
                    hasLinks = true;
                }
                
                // Show EGW (Logic: Hide if Bible detected? User said "If bible reference is detected... show up as URL...".
                // Did user retract the "Hide EGW" req?
                // "The app also ceased to show links to EGW...".
                // I will allow EGW to show alongside BibleGateway link if both exist (rare but possible).
                // Or I can keep the logic: If bible_data exists, maybe EGW is false positive?
                // With strict regex, false positive is unlikely.
                // Let's show both if present.
                if (data.egw_data && data.egw_data.en) {
                     linksSpan.innerHTML += `<a href="${data.egw_data.en}" target="_blank" class="me-2 btn btn-sm btn-outline-info">EGW</a>`;
                     hasLinks = true;
                }
                
                if (hasLinks) {
                    linksSection.style.display = 'block';
                } else {
                    linksSection.style.display = 'none';
                }
            });
    }
    
    function saveSegment(id) {
        if (!id) return;
        const target = document.getElementById('target-input').value;
        const note = document.getElementById('note-input').value;
        const statusInd = document.getElementById('status-indicator');
        
        statusInd.innerText = "Saving...";
        statusInd.className = "badge bg-warning text-dark border";
        
        fetch(`/api/segment/${id}/save`, {
            method: 'POST',
            headers: {'Content-Type': 'application/json'},
            body: JSON.stringify({target_text: target, note: note})
        }).then(r => {
            statusInd.innerText = "Saved";
            statusInd.className = "badge bg-light text-dark border";
            
            const item = document.getElementById(`seg-item-${id}`);
            if (target.trim()) {
                item.classList.add('translated');
            } else {
                item.classList.remove('translated');
            }
            updateProgress();
        });
    }
    
    document.getElementById('target-input').addEventListener('blur', () => {
        saveSegment(currentSegmentId);
    });
    
    // Initial Progress
    updateProgress();

    function nextSegment() {
        const idx = segments.indexOf(currentSegmentId);
        if (idx >= 0 && idx < segments.length - 1) {
            loadSegment(segments[idx + 1]);
        }
    }
    
    function prevSegment() {
        const idx = segments.indexOf(currentSegmentId);
        if (idx > 0) {
            loadSegment(segments[idx - 1]);
        }
    }
    
    function copySource() {
        const src = document.getElementById('source-display').innerText;
        document.getElementById('target-input').value = src;
        saveSegment(currentSegmentId);
    }
    
    function useTM() {
        if (currentTmMatch) {
            document.getElementById('target-input').value = currentTmMatch;
            saveSegment(currentSegmentId);
        }
    }
    
    function requestMT() {
        const text = document.getElementById('source-display').innerText;
        
        // Get Key from LocalStorage
        const apiKey = localStorage.getItem('glossio_deepl_key');
        if (!apiKey) {
            alert("Please configure your DeepL API Key in Settings first.");
            // Open settings
            const modal = new bootstrap.Modal(document.getElementById('settingsModal'));
            modal.show();
            return;
        }

        const statusInd = document.getElementById('status-indicator');
        statusInd.innerText = "Translating...";
        statusInd.className = "badge bg-info text-dark border";

        // Get target lang from project context (passed from backend)
        const targetLang = "{{ project.target_lang }}"; 

        fetch('/api/translate/mt', {
            method: 'POST',
            headers: {'Content-Type': 'application/json'},
            body: JSON.stringify({
                text: text, 
                target_lang: targetLang,
                api_key: apiKey
            }) 
        }).then(r => r.json())
        .then(data => {
            statusInd.innerText = "Saved";
            statusInd.className = "badge bg-light text-dark border";
            
            if(data.translation) {
                 document.getElementById('target-input').value = data.translation;
                 saveSegment(currentSegmentId);
            } else {
                alert("MT Error: " + (data.error || "Unknown"));
            }
        });
    }
    
    function mergePrev() {
        if(!confirm("Merge with previous segment?")) return;
        fetch(`/api/segment/${currentSegmentId}/merge_prev`, {
            method: 'POST'
        }).then(r => r.json())
        .then(data => {
            if(data.status === 'success') {
                // Reload and jump to the merged segment (new_id is the previous segment ID)
                window.location.href = window.location.pathname + "?segment=" + data.new_id;
            } else {
                alert(data.message);
            }
        });
    }

    // Keyboard Shortcuts
    document.addEventListener('keydown', function(e) {
        if (e.ctrlKey && e.key === 'n') { e.preventDefault(); nextSegment(); }
        if (e.ctrlKey && e.key === 'b') { e.preventDefault(); prevSegment(); }
        if (e.ctrlKey && e.key === 'i') { e.preventDefault(); copySource(); }
        if (e.ctrlKey && e.key === 't') { e.preventDefault(); useTM(); }
        if (e.ctrlKey && e.key === 'j') { e.preventDefault(); mergePrev(); }
    });
    
    // Initial load
    const urlParams = new URLSearchParams(window.location.search);
    const startSeg = urlParams.get('segment');
    if (startSeg) {
        loadSegment(startSeg);
        // Clean URL
        window.history.replaceState({}, document.title, window.location.pathname);
    } else {
        {% if structure and structure[0].segments %}
            loadSegment({{ structure[0].segments[0].id }});
        {% endif %}
    }

</script>

<!-- Search Modal -->
<div class="modal fade" id="searchModal" tabindex="-1">
  <div class="modal-dialog">
    <div class="modal-content">
      <div class="modal-header">
        <h5 class="modal-title">Search in Project</h5>
        <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
      </div>
      <div class="modal-body">
         <div class="input-group mb-3">
             <input type="text" id="search-query" class="form-control" placeholder="Search text...">
             <select id="search-type" class="form-select" style="max-width: 100px;">
                 <option value="source">Source</option>
                 <option value="target">Target</option>
             </select>
             <button class="btn btn-primary" onclick="performSearch()">Search</button>
         </div>
         <div id="search-results" class="list-group" style="max-height: 300px; overflow-y: auto;"></div>
      </div>
    </div>
  </div>
</div>

<script>
    function performSearch() {
        const query = document.getElementById('search-query').value.trim();
        const type = document.getElementById('search-type').value;
        const resultsDiv = document.getElementById('search-results');
        
        if (!query) return;

        // Check for Go To Segment pattern (e.g. "1.1")
        if (/^\d+\.\d+$/.test(query)) {
             fetch(`/api/segment/get_by_display_id?project_id={{ project.id }}&display_id=${query}`)
                .then(r => r.json())
                .then(data => {
                    if (data.segment_id) {
                        loadSegment(data.segment_id);
                        // Close modal
                        const modal = bootstrap.Modal.getInstance(document.getElementById('searchModal'));
                        modal.hide();
                    } else {
                        resultsDiv.innerHTML = '<div class="text-center text-danger">Segment not found</div>';
                    }
                });
             return;
        }
        
        resultsDiv.innerHTML = '<div class="text-center">Searching...</div>';
        
        fetch(`/api/project/{{ project.id }}/search?q=${encodeURIComponent(query)}&type=${type}`)
            .then(r => r.json())
            .then(data => {
                resultsDiv.innerHTML = '';
                if(data.length === 0) {
                    resultsDiv.innerHTML = '<div class="text-center">No results found</div>';
                    return;
                }
                
                data.forEach(item => {
                    const el = document.createElement('a');
                    el.href = '#';
                    el.className = 'list-group-item list-group-item-action';
                    el.innerHTML = `<b>[${item.p_idx+1}.${item.s_idx+1}]</b> ${item.match_text}`;
                    el.onclick = (e) => {
                        e.preventDefault();
                        loadSegment(item.id);
                        // Close modal
                        const modalEl = document.getElementById('searchModal');
                        const modal = bootstrap.Modal.getInstance(modalEl);
                        modal.hide();
                    };
                    resultsDiv.appendChild(el);
                });
            });
    }
    
    document.getElementById('search-query').addEventListener('keyup', function(e) {
        if (e.key === 'Enter') performSearch();
    });
    
    // --- Bible Logic Refactored (Manual Selectors) ---
    const targetLangCode = "{{ project.target_lang }}".toUpperCase(); 
    
    function initBible() {
        fetch('/api/bible/versions')
            .then(r => r.json())
            .then(data => {
                const select = document.getElementById('bible-version-select');
                select.innerHTML = '';
                
                let count = 0;
                data.forEach(langNode => {
                    if (langNode.translations) {
                        langNode.translations.forEach(t => {
                            const opt = document.createElement('option');
                            opt.value = t.short_name;
                            opt.innerText = `${t.full_name} (${langNode.language})`; 
                            select.appendChild(opt);
                            count++;
                        });
                    }
                });
                
                if (count === 0) {
                     select.add(new Option("No translations found", ""));
                } else {
                    // Auto-select logic
                    const LANG_MAP = {
                        'EN': ['English'], 'ES': ['Spanish', 'Español'], 'FR': ['French', 'Français'], 
                        'DE': ['German', 'Deutsch'], 'PT': ['Portuguese', 'Português'],
                        'IT': ['Italian', 'Italiano'], 'RU': ['Russian', 'Русский'], 
                        'ZH': ['Chinese', '中文']
                    };
                    const keywords = (LANG_MAP[targetLangCode.substring(0,2)] || []).map(s => s.toLowerCase());
                    if (keywords.length > 0) {
                        for (let i = 0; i < select.options.length; i++) {
                            if (keywords.some(k => select.options[i].text.toLowerCase().includes(k))) {
                                select.selectedIndex = i;
                                break;
                            }
                        }
                    }
                }
                
                // Trigger Book fetch for selected version
                onVersionChange();
            })
            .catch(e => alert("Bible versions load error: " + e.message));
    }
    
    // Call on load
    initBible();
    
    function onVersionChange() {
        const version = document.getElementById('bible-version-select').value;
        if(!version) return;
        
        fetch(`/api/bible/books/${version}`)
            .then(r => r.json())
            .then(data => {
                const bookSelect = document.getElementById('bible-book-select');
                bookSelect.innerHTML = '<option value="">Select Book...</option>';
                data.forEach(b => {
                    const opt = document.createElement('option');
                    opt.value = b.bookid; // Int
                    opt.innerText = b.name;
                    bookSelect.appendChild(opt);
                });
            });
    }
    
    function fetchCustomBibleText() {
        const version = document.getElementById('bible-version-select').value;
        const book = document.getElementById('bible-book-select').value;
        const chapter = document.getElementById('bible-chapter-input').value;
        const verseInput = document.getElementById('bible-verse-input').value.trim();
        
        if(!version || !book || !chapter) {
            alert("Please select Version, Book and Chapter.");
            return;
        }
        
        const display = document.getElementById('bible-content-area');
        display.innerText = "Loading...";
        
        // Fetch full chapter
        fetch(`/api/bible/text/${version}/${book}/${chapter}`)
            .then(r => r.json())
            .then(data => {
                // data is Array of {verse, text, pk}
                if(!Array.isArray(data) || data.length === 0) {
                    display.innerText = "No text found.";
                    return;
                }
                
                let filtered = [];
                // Parse verse input: "1" or "2-5" or empty (all)
                if (verseInput) {
                    if (verseInput.includes('-')) {
                        const parts = verseInput.split('-');
                        const start = parseInt(parts[0]);
                        const end = parseInt(parts[1]);
                        filtered = data.filter(v => v.verse >= start && v.verse <= end);
                    } else {
                        const vNum = parseInt(verseInput);
                        filtered = data.filter(v => v.verse === vNum);
                    }
                } else {
                    filtered = data; // All
                }
                
                if(filtered.length === 0) {
                    display.innerText = "Verses not found in chapter.";
                    return;
                }
                
                // Format output
                let html = filtered.map(v => {
                    // Strip existing HTML tags in text?
                    let doc = new DOMParser().parseFromString(v.text, 'text/html');
                    return `<p><sup>${v.verse}</sup> ${doc.body.textContent}</p>`;
                }).join("");
                
                display.innerHTML = html;
            })
            .catch(e => display.innerText = "Error: " + e.message);
    }
    
    function setBibleSelector(bookId, chapter, verse) {
        // Set values
        const bookSelect = document.getElementById('bible-book-select');
        const chInput = document.getElementById('bible-chapter-input');
        const vInput = document.getElementById('bible-verse-input');
        
        bookSelect.value = bookId;
        chInput.value = chapter;
        vInput.value = verse;
        
        // Trigger fetch
        fetchCustomBibleText();
    }
    
    function highlightRefs(text, bibleData, egwData) {
        let html = text;
        
        // Escape helper for regex
        const escapeRegExp = (string) => string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');

        // Highlight EGW
        if (egwData && egwData.match && egwData.en) {
            const pattern = new RegExp(escapeRegExp(egwData.match), 'g');
            html = html.replace(pattern, `<a href="${egwData.en}" target="_blank" class="text-info text-decoration-underline fw-bold">${egwData.match}</a>`);
        }

        // Highlight Bible
        if (bibleData && bibleData.api_data && bibleData.match) {
            const { book_id, chapter, verse } = bibleData.api_data;
            const pattern = new RegExp(escapeRegExp(bibleData.match), 'g');
            html = html.replace(pattern, `<a href="#" class="text-primary text-decoration-underline fw-bold" onclick="setBibleSelector(${book_id}, ${chapter}, '${verse}'); return false;">${bibleData.match}</a>`);
        }
        
        return html;
    }
    
    function pasteBibleText() {
        const text = document.getElementById('bible-content-area').innerText;
        // Strip the reference suffix for pasting? "Text (REF)"
        // Let's paste what is visible.
        if (text && !text.startsWith("Loading") && !text.startsWith("Error")) {
            const target = document.getElementById('target-input');
            target.value = text;
            saveSegment(currentSegmentId);
        }
    }
</script>
{% endblock %}
